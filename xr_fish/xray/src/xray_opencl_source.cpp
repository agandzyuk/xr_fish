
extern const char XRAY_OPENCL_SOURCE[] =
        //--------------------------------------------------------------------------
"\n"
"\n     struct XRay"
"\n     {"
"\n         float4 Origin;"
"\n         float4 Direct;"
"\n     }"
"\n"
"\n     struct Intersection"
"\n     {"
"\n         float4 Normal;"
"\n         float Time;"
"\n         float U;"
"\n         float V;"
"\n     }"
"\n"
"\n"
"\n     #define ZERO (float4)( 0.f, 0.f, 0.f, 0.f )"
"\n     #define UNIT (float4)( 1.f, 1.f, 1.f, 0.f )"
"\n"
"\n     #define AXIS_X (float4)( 1.f, 0.f, 0.f, 0.f )"
"\n     #define AXIS_Y (float4)( 0.f, 1.f, 0.f, 0.f )"
"\n     #define AXIS_Z (float4)( 0.f, 0.f, 1.f, 0.f )"
"\n"
"\n"
        //--------------------------------------------------------------------------
"\n     void CreateRay(XRay*         pRay,"
"\n                    const float   X,"
"\n                    const float   Y,"
"\n                    const int     sizeX,"
"\n                    const int     sizeY,"
"\n                    const float16 origins,"
"\n                    const float16 directions )"
"\n     {"
"\n         float2 pixel = (float2)(X / (float)sizeX, Y / (float)sizeY);"
"\n"
"\n         float4 pt0 = mix(origins.lo.lo, origins.lo.hi, pixel.x);"
"\n         float4 pt1 = mix(origins.hi.lo, origins.hi.hi, pixel.x);"
"\n"
"\n         pRay->Origin = mix(pt0, pt1, pixel.y);"
"\n"
"\n         pt0 = mix(directions.lo.lo, directions.lo.hi, pixel.x);"
"\n         pt1 = mix(directions.hi.lo, directions.hi.hi, pixel.x);"
"\n"
"\n         pRay->Direct = mix(pt0, pt1, pixel.y);"
"\n     }"
"\n"
"\n"
        //--------------------------------------------------------------------------
"\n"
"\n     #define OEXPS exp2( -80.f )"
"\n"
"\n     bool SphereIntersection( const XRay* pRay, float radius, float* pTime )"
"\n     {"
"\n         float fDD = dot(pRay->Direct.xyz, pRay->Direct.xyz);"
"\n         float fDO = dot(pRay->Direct.xyz, pRay->Origin.xyz);"
"\n         float fOO = dot(pRay->Origin.xyz, pRay->Origin.xyz);"
"\n"
"\n         float fD = fDO * fDO - fDD * (fOO - radius * radius);"
"\n         if( fD > 0.f )"
"\n         {"
"\n             *pTime = (-fDO + native_sqrt (fD)) * (1.f / fDD);"
"\n             return (*pTime > 0.f);"
"\n         }"
"\n         return false;"
"\n     }"
"\n"
        //--------------------------------------------------------------------------
"\n     bool BoxIntersection( const XRay* pRay,"
"\n                           float4      minPoint,"
"\n                           float4      maxPoint,"
"\n                           float*      pTimeStart,"
"\n                           float*      pTimeFinal )"
"\n     {"
"\n         const float4 invDirect = (float4)("
"\n                     1.f / (fabs(pRay->Direct.x) > OEXPS ?"
"\n                            pRay->Direct.x : copysign(OEXPS, pRay->Direct.x)),"
"\n                     1.f / (fabs(pRay->Direct.y) > OEXPS ?"
"\n                            pRay->Direct.y : copysign(OEXPS, pRay->Direct.y)),"
"\n                     1.f / (fabs(pRay->Direct.z) > OEXPS ?"
"\n                            pRay->Direct.z : copysign(OEXPS, pRay->Direct.z)),"
"\n                     0.f);"
"\n"
"\n         const float4 time0 = (minPoint - pRay->Origin) * invDirect;"
"\n         const float4 time1 = (maxPoint - pRay->Origin) * invDirect;"
"\n"
"\n         const float4 timeMax = max( time0, time1 );"
"\n         const float4 timeMin = min( time0, time1 );"
"\n"
"\n         *pTimeFinal = min( timeMax.x, min( timeMax.y, timeMax.z ) );"
"\n         *pTimeStart = max( timeMin.x, max( timeMin.y, timeMin.z ) );"
"\n"
"\n         return (*pTimeStart <= *pTimeFinal) & (*pTimeFinal >= 0.f);"
"\n     }"
"\n"
        //--------------------------------------------------------------------------
"\n     void NodesIntersection( const XRay* pRay,"
"\n                             float4      minPoint0,"
"\n                             float4      maxPoint0,"
"\n                             float4      minPoint1,"
"\n                             float4      maxPoint1,"
"\n                             float*      pTimeStart0,"
"\n                             float*      pTimeStart1,"
"\n                             float       maxTime )"
"\n     {"
"\n         const float4 invDirect = (float4)("
"\n                     1.f / (fabs(pRay->Direct.x) > OEXPS ?"
"\n                            pRay->Direct.x : copysign(OEXPS, pRay->Direct.x)),"
"\n                     1.f / (fabs(pRay->Direct.y) > OEXPS ?"
"\n                            pRay->Direct.y : copysign(OEXPS, pRay->Direct.y)),"
"\n                     1.f / (fabs(pRay->Direct.z) > OEXPS ?"
"\n                            pRay->Direct.z : copysign(OEXPS, pRay->Direct.z)),"
"\n                     0.f);"
"\n"
"\n         float4 time0 = (minPoint0 - pRay->Origin) * invDirect;"
"\n         float4 time1 = (maxPoint0 - pRay->Origin) * invDirect;"
"\n"
"\n         float4 timeMax = max( time0, time1 );"
"\n         float4 timeMin = min( time0, time1 );"
"\n"
"\n         time0 = (minPoint1 - pRay->Origin) * invDirect;"
"\n         time1 = (maxPoint1 - pRay->Origin) * invDirect;"
"\n"
"\n         float timeFinal = min( timeMax.x, min( timeMax.y, timeMax.z ) );"
"\n         float timeStart = max( timeMin.x, max( timeMin.y, timeMin.z ) );"
"\n"
"\n         timeMax = max( time0, time1 );"
"\n         timeMin = min( time0, time1 );"
"\n"
"\n         *pTimeStart0 = (timeStart <= timeFinal) & (timeFinal >= 0.f) & (timeStart <= maxTime)"
"\n                        ? timeStart : -MAXFLOAT;"
"\n"
"\n         timeFinal = min( timeMax.x, min( timeMax.y, timeMax.z ) );"
"\n         timeStart = max( timeMin.x, max( timeMin.y, timeMin.z ) );"
"\n"
"\n         *pTimeStart1 = (timeStart <= timeFinal) & (timeFinal >= 0.f) & (timeStart <= maxTime)"
"\n                        ? timeStart : -MAXFLOAT;"
"\n     }"
"\n"
        //--------------------------------------------------------------------------
"\n     bool TriangleIntersection( const XRay*  pRay,"
"\n                                const float4 point0,"
"\n                                const float4 point1,"
"\n                                const float4 point2,"
"\n                                float4*      pNormal,"
"\n                                float*       pTime,"
"\n                                float*       pU,"
"\n                                float*       pV )"
"\n     {"
"\n         const float4 edge0 = point1 - point0;"
"\n         const float4 edge1 = point0 - point2;"
"\n         *pNormal = cross(edge1, edge0);"
"\n"
"\n         const float4 edge2 = (1.f / dot(*pNormal, pRay->Direct)) * (point0 - pRay->Origin);"
"\n         *pTime = dot( *pNormal, edge2 );"
"\n"
"\n         const float4 inc = cross( pRay->Direct, edge2 );"
"\n         *pU = dot( inc, edge1 );"
"\n         *pV = dot( inc, edge0 );"
"\n"
"\n         return (*pTime > 0) & (*pU >= 0.f) & (*pV >= 0.f) & (*pU + *pV <= 1.f);"
"\n     }"
"\n"
        //-------------------------------------------------------------------------- 
"\n"
"\n     const sampler_t EnvSampler = CLK_NORMALIZED_COORDS_TRUE |"
"\n                                  CLK_ADDRESS_REPEAT |"
"\n                                  CLK_FILTER_LINEAR;"
"\n"
        //--------------------------------------------------------------------------
"\n     float4 SmoothNormal( __global float4*    gNormals,"
"\n                          const Intersection* pHit,"
"\n                          const int4          indices )"
"\n     {"
"\n         float4 normal0 = gNormals[indices.x],"
"\n                normal1 = gNormals[indices.y],"
"\n                normal2 = gNormals[indices.z];"
"\n"
"\n         return fast_normalize( normal1 * pHit->U +"
"\n                          normal2 * pHit->V +"
"\n                          normal0 * (1.f - pHit->U - pHit->V) );"
"\n     }"
"\n"
        //--------------------------------------------------------------------------
"\n     float4 Shade( __global float4* gMaterials,"
"\n                   const float4     light,"
"\n                   const float4     view,"
"\n                   const float4     normal,"
"\n                   const float4     intens,"
"\n                   const float      transpr,"
"\n                   const int        matIndex )"
"\n     {"
"\n         float lambert = dot(normal, light);"
"\n         lambert = transpr > 0.f ? fabs(lambert) : lambert;"
"\n"
"\n         if( lambert > 0.f )"
"\n         {"
"\n             const float4 matDiff = gMaterials[7 * matIndex + 1];"
"\n             const float4 matSpec = gMaterials[7 * matIndex + 2];"
"\n"
"\n             const float4 reflect  = 2.f * dot(light, normal) * normal - light;"
"\n             const float  specular = pow(max(dot(reflect.xyz, view.xyz), 0.f), matSpec.w);"
"\n"
"\n             return (intens * (matDiff * lambert + matSpec * specular));"
"\n         }"
"\n         return ZERO;"
"\n     }"
"\n"
        //--------------------------------------------------------------------------
"\n     float2 LatLong( const float4 direct )"
"\n     {"
"\n         float psi = acos( -direct.y );"
"\n         float phi = atan2( direct.z, direct.x );"
"\n         phi = (phi < 0) ? (phi + 2.f * M_PI_F) : phi;"
"\n"
"\n         return (float2)(phi / (2.f * M_PI_F), psi / M_PI_F);"
"\n     }"
"\n"
"\n"
        //--------------------------------------------------------------------------
"\n     void push( uint* pStack, char* pPos, const uint value )"
"\n     {"
"\n         (*pPos)++;"
"\n         pStack[*pPos] = value;"
"\n     }"
"\n"
        //--------------------------------------------------------------------------
"\n     void pop( uint* pStack, char* pPos, uint* pValue )"
"\n     {"
"\n         *pValue = pStack[*pPos];"
"\n         (*pPos)--;"
"\n     }"
"\n"
        //--------------------------------------------------------------------------
"\n     int4 Traverse( const XRay*      pRay,"
"\n                    __global int4*   gIndices,"
"\n                    __global float4* gVertices,"
"\n                    __global float4* gNodeMinPoints,"
"\n                    __global float4* gNodeMaxPoints,"
"\n                    __global int4*   gNodeDataRecords,"
"\n                    Intersection*    pHit )"
"\n     {"
"\n         uint stack[32];"
"\n         uint node = 0;"
"\n         char head = -1;"
"\n"
"\n         float timeMin1;"
"\n         float timeMin2;"
"\n"
"\n         float4 nodeMinLft;"
"\n         float4 nodeMaxLft;"
"\n         float4 nodeMinRgh;"
"\n         float4 nodeMaxRgh;"
"\n"
"\n     #ifdef SAH_MINIMIZE_MEM_LOADS"
"\n         nodeMinLft = gNodeMinPoints[node];"
"\n         nodeMaxLft = gNodeMaxPoints[node];"
"\n     #endif"
"\n"
"\n         int4 triangleIndex = (int4) (-1);"
"\n         pHit->Time = MAXFLOAT;"
"\n"
"\n     #ifdef SAH_MINIMIZE_MEM_LOADS"
"\n         int3 aData = (int3)(1,"
"\n                             as_int(nodeMinLft.w),"
"\n                             as_int(nodeMaxLft.w));"
"\n         aData = aData.y < 0 ? -aData : aData;"
"\n     #endif"
"\n"
"\n         while( true )"
"\n         {"
"\n     #ifndef SAH_MINIMIZE_MEM_LOADS"
"\n             int3 aData = gNodeDataRecords[node].xyz;"
"\n     #endif"
"\n"
"\n             if( aData.x != 1 )"
"\n             {"
"\n                 nodeMinLft = gNodeMinPoints[aData.y];"
"\n                 nodeMinRgh = gNodeMinPoints[aData.z];"
"\n                 nodeMaxLft = gNodeMaxPoints[aData.y];"
"\n                 nodeMaxRgh = gNodeMaxPoints[aData.z];"
"\n"
"\n                 NodesIntersection( pRay,"
"\n                                    nodeMinLft,"
"\n                                    nodeMaxLft,"
"\n                                    nodeMinRgh,"
"\n                                    nodeMaxRgh,"
"\n                                    &timeMin1,"
"\n                                    &timeMin2,"
"\n                                    pHit->Time );"
"\n"
"\n                 const bool hitL = (timeMin1 != -MAXFLOAT);"
"\n                 const bool hitR = (timeMin2 != -MAXFLOAT);"
"\n"
"\n                 if( hitL & hitR )"
"\n                 {"
"\n                     node = (timeMin1 < timeMin2) ? aData.y : aData.z;"
"\n                     push( aStack, &head, (timeMin1 < timeMin2) ? aData.z : aData.y );"
"\n"
"\n     #ifdef SAH_MINIMIZE_MEM_LOADS"
"\n                     aData = (int3)(1,"
"\n                                    as_int(timeMin1 < timeMin2 ? nodeMinLft.w : nodeMinRgh.w),"
"\n                                    as_int(timeMin1 < timeMin2 ? nodeMaxLft.w : nodeMaxRgh.w));"
"\n                     aData = aData.y < 0 ? -aData : aData;"
"\n     #endif"
"\n                 }"
"\n                 else"
"\n                 {"
"\n                     if( hitL | hitR )"
"\n                     {"
"\n                         node = hitL ? aData.y : aData.z;"
"\n"
"\n     #ifdef SAH_MINIMIZE_MEM_LOADS"
"\n                         aData = (int3)(1,"
"\n                                        as_int(hitL ? nodeMinLft.w : nodeMinRgh.w),"
"\n                                        as_int(hitL ? nodeMaxLft.w : nodeMaxRgh.w));"
"\n                         aData = aData.y < 0 ? -aData : aData;"
"\n     #endif"
"\n                     }"
"\n                     else"
"\n                     {"
"\n                         if( head < 0 )"
"\n                             return triangleIndex;"
"\n"
"\n                         pop( aStack, &head, &node );"
"\n     #ifdef SAH_MINIMIZE_MEM_LOADS"
"\n                         aData = gNodeDataRecords[node].xyz;"
"\n     #endif"
"\n                     }"
"\n                 }"
"\n             }"
"\n             else "
"\n             {"
"\n                 for( int nTri = aData.y; nTri <= aData.z; ++nTri )"
"\n                 {"
"\n                     int4 index = gIndices[nTri];"
"\n"
"\n                     const float4 p0 = gVertices[index.x];"
"\n                     const float4 p1 = gVertices[index.y];"
"\n                     const float4 p2 = gVertices[index.z];"
"\n"
"\n                     float4 normal;"
"\n                     float fTime, fU, fV;"
"\n"
"\n                     if( TriangleIntersection( pRay,"
"\n                                               p0,"
"\n                                               p1,"
"\n                                               p2,"
"\n                                               &normal,"
"\n                                               &fTime,"
"\n                                               &fU,"
"\n                                               &fV ) & (fTime < pHit->Time) )"
"\n                     {"
"\n                         triangleIndex = index;"
"\n                         pHit->Normal  = normal;"
"\n                         pHit->Time    = fTime;"
"\n                         pHit->U       = fU;"
"\n                         pHit->V       = fV;"
"\n                     }"
"\n                 }"
"\n"
"\n                 if( head < 0 )"
"\n                     return triangleIndex;"
"\n"
"\n                 pop( aStack, &head, &node );"
"\n"
"\n     #ifdef SAH_MINIMIZE_MEM_LOADS"
"\n                 aData = gNodeDataRecords[node].xyz;"
"\n     #endif"
"\n             }"
"\n         }"
"\n         return triangleIndex;"
"\n     }"
"\n"
"\n     #define TRANSPARENT_SHADOW_"
"\n"
        //--------------------------------------------------------------------------
"\n     float TraverseShadow( const XRay*      pRay,"
"\n                           __global int4*   gIndices,"
"\n                           __global float4* gVertices,"
"\n                           __global float4* gMaterials,"
"\n                           __global float4* gNodeMinPoints,"
"\n                           __global float4* gNodeMaxPoints,"
"\n                           __global int4*   gNodeDataRecords,"
"\n                           float            distance )"
"\n   {"
"\n         uint aStack[32];"
"\n         uint node = 0;"
"\n         char head = -1;"
"\n"
"\n         float factor = 1.f;"
"\n         float timeMin1;"
"\n         float timeMin2;"
"\n"
"\n         while( true )"
"\n         {"
"\n             int3 aData = gNodeDataRecords[node].xyz;"
"\n"
"\n             if( aData.x != 1 )"
"\n             {"
"\n                 NodesIntersection( pRay,"
"\n                                    gNodeMinPoints[aData.y],"
"\n                                    gNodeMaxPoints[aData.y],"
"\n                                    gNodeMinPoints[aData.z],"
"\n                                    gNodeMaxPoints[aData.z],"
"\n                                    &timeMin1,"
"\n                                    &timeMin2,"
"\n                                    distance );"
"\n                 const bool hitL = (timeMin1 != -MAXFLOAT);"
"\n                 const bool hitR = (timeMin2 != -MAXFLOAT);"
"\n"
"\n                 if( hitL & hitR )"
"\n                 {"
"\n                     node = (timeMin1 < timeMin2) ? aData.y : aData.z;"
"\n                     push( aStack, &head, (timeMin1 < timeMin2) ? aData.z : aData.y );"
"\n                 }"
"\n                 else"
"\n                 {"
"\n                     if( hitL | hitR )"
"\n                     {"
"\n                         node = hitL ? aData.y : aData.z;"
"\n                     }"
"\n                     else"
"\n                     {"
"\n                         if( head < 0 )"
"\n                             return factor;"
"\n"
"\n                         pop( aStack, &head, &node );"
"\n                     }"
"\n                 }"
"\n             }"
"\n             else "
"\n             {"
"\n                 for( int nTri = aData.y; nTri <= aData.z; ++nTri )"
"\n                 {"
"\n                     int4 index = gIndices[nTri];"
"\n"
"\n                     const float4 p0 = gVertices[index.x];"
"\n                     const float4 p1 = gVertices[index.y];"
"\n                     const float4 p2 = gVertices[index.z];"
"\n"
"\n                     float4 normal;"
"\n                     float fTime, fU, fV;"
"\n"
"\n                     if( TriangleIntersection( pRay,"
"\n                                               p0,"
"\n                                               p1,"
"\n                                               p2,"
"\n                                               &normal,"
"\n                                               &fTime,"
"\n                                               &fU,"
"\n                                               &fV ) & (fTime < distance) )"
"\n                     {"
"\n     #ifdef TRANSPARENT_SHADOW"
"\n                         factor *= gMaterials[7 * index.w + 6].x;"
"\n                         if( factor < 0.1f )"
"\n                             return factor;"
"\n     #else"
"\n                         return 0.f;"
"\n     #endif"
"\n                     }"
"\n                 }"
"\n                 if( head < 0 )"
"\n                     return factor;"
"\n                 pop( aStack, &head, &node );"
"\n             }"
"\n         }"
"\n         return factor;"
"\n     }"
"\n"
"\n     #define DEPTH_MAX 5"
"\n     #define SIZE_MAT  7"
"\n     #define SIZE_LGH  3"
"\n"
        //--------------------------------------------------------------------------
"\n     float4 Raytrace( XRay* pRay,"
"\n                      __read_only image2d_t anEnvMap,"
"\n                      __global float4* gNodeMinPoints,"
"\n                      __global float4* gNodeMaxPoints,"
"\n                      __global int4*   gNodeDataRecords,"
"\n                      __global float4* gLightSources,"
"\n                      __global float4* gMaterials,"
"\n                      __global float4* gVertices,"
"\n                      __global float4* gNormals,"
"\n                      __global int4*   gIndices,"
"\n                      const int        lightCount,"
"\n                      const float      epsilon,"
"\n                      const float      radius,"
"\n                      const int        isShadows,"
"\n                      const int        isReflect )"
"\n     {"
"\n         float4 result = (float4)(0.f, 0.f, 0.f, 0.f);"
"\n         float4 weight = (float4)(1.f, 1.f, 1.f, 1.f);"
"\n"
"\n         Intersection aHit;"
"\n"
"\n         for( int depth = 0; depth < DEPTH_MAX; ++depth )"
"\n         {"
"\n             int4 triangle = Traverse( pRay,"
"\n                                       gIndices,"
"\n                                       gVertices,"
"\n                                       gNodeMinPoints,"
"\n                                       gNodeMaxPoints,"
"\n                                       gNodeDataRecords,"
"\n                                       &aHit );"
"\n             if( triangle.x < 0.f )"
"\n             {"
"\n                 float fTime;"
"\n"
"\n                 if( weight.w != 0.f || !SphereIntersection( pRay, radius, &fTime ) )"
"\n                     break;"
"\n"
"\n                 float2 texCoord = LatLong( fma( pRay->Direct,"
"\n                                             (float4)(fTime),"
"\n                                             pRay->Origin) * (1.f / radius ) );"
"\n                 result += weight * read_imagef( anEnvMap, EnvSampler, texCoord );"
"\n                 return (float4)(result.x,"
"\n                                 result.y,"
"\n                                 result.z,"
"\n                                 weight.w);"
"\n             }"
"\n             "
"\n             float4 geomNormal = aHit.Normal;"
"\n             geomNormal = fast_normalize( geomNormal );"
"\n"
"\n             "
"\n             float4 normal = SmoothNormal( gNormals, &aHit, triangle );"
"\n"
"\n             "
"\n             float4 point    = pRay->Direct * aHit.Time + pRay->Origin;"
"\n             float4 materAmb = gMaterials[SIZE_MAT * triangle.w + 0];"
"\n             float4 materTrn = gMaterials[SIZE_MAT * triangle.w + 6];"
"\n"
"\n             for( int light = 0; light < lightCount; ++light )"
"\n             {"
"\n                 float4 lightAmbient = gLightSources[SIZE_LGH * light];"
"\n                 result += weight * lightAmbient * materAmb *"
"\n                           (materTrn.x * max( fabs( dot( pRay->Direct, normal ) ), 0.5f ) );"
"\n"
"\n                 if( lightAmbient.w < 0.f )"
"\n                     continue;"
"\n"
"\n                 float4 lightPosition = gLightSources[SIZE_LGH * light + 2];"
"\n"
"\n                 XRay aShadow;"
"\n                 aShadow.Direct = lightPosition;"
"\n"
"\n                 float lightDistance = MAXFLOAT;"
"\n                 if( lightPosition.w != 0.f )"
"\n                 {"
"\n                     lightDistance = length( lightPosition - point );"
"\n                     aShadow.Direct = (lightPosition - point) * (1.f / lightDistance);"
"\n                 }"
"\n"
"\n                 aShadow.Origin = point + aShadow.Direct * epsilon +"
"\n                                  geomNormal * copysign( epsilon, dot( geomNormal, aShadow.Direct ) );"
"\n"
"\n                 float factor = 1.f;"
"\n                 if( isShadows )"
"\n                 {"
"\n                     factor = TraverseShadow( &aShadow,"
"\n                                              gIndices,"
"\n                                              gVertices,"
"\n                                              gMaterials,"
"\n                                              gNodeMinPoints,"
"\n                                              gNodeMaxPoints,"
"\n                                              gNodeDataRecords,"
"\n                                              lightDistance );"
"\n                 }"
"\n                 result += (materTrn.x * factor) * weight * Shade( gMaterials,"
"\n                                                                 aShadow.Direct,"
"\n                                                                -pRay->Direct,"
"\n                                                                 normal,"
"\n                                                                 UNIT,"
"\n                                                                 materTrn.y,"
"\n                                                                 triangle.w );"
"\n             }"
"\n             if( materTrn.y > 0.f )"
"\n             {"
"\n                 weight *= materTrn.y;"
"\n             }"
"\n             else"
"\n             {"
"\n                 float4 materRef = gMaterials[SIZE_MAT * triangle.w + 4];"
"\n                 weight *= isReflect ? materRef : ZERO;"
"\n"
"\n                 pRay->Direct -= 2.f * dot( pRay->Direct, normal ) * normal;"
"\n"
"\n                 float aDdotN = dot( pRay->Direct, geomNormal );"
"\n                 if( aDdotN < 0.f )"
"\n                     pRay->Direct -= aDdotN * geomNormal;"
"\n             }"
"\n"
"\n             if( weight.x < 0.1f && weight.y < 0.1f && weight.z < 0.1f )"
"\n             {"
"\n                 return (float4)(result.x,"
"\n                                 result.y,"
"\n                                 result.z,"
"\n                                 weight.w);"
"\n             }"
"\n"
"\n             pRay->Origin = pRay->Direct * epsilon + point;"
"\n         }"
"\n         return (float4)(result.x,"
"\n                         result.y,"
"\n                         result.z,"
"\n                         weight.w);"
"\n     }"
"\n"
"\n"
        //--------------------------------------------------------------------------
"\n   __kernel void Main( __write_only image2d_t anOutput,"
"\n                       __read_only  image2d_t anEnvMap,"
"\n                       __global float4* gNodeMinPoints,"
"\n                       __global float4* gNodeMaxPoints,"
"\n                       __global int4*   gNodeDataRecords,"
"\n                       __global float4* gLightSources,"
"\n                       __global float4* gMaterials,"
"\n                       __global float4* gVertices,"
"\n                       __global float4* gNormals,"
"\n                       __global int4*   gIndices,"
"\n                       const float16    origins,"
"\n                       const float16    directs,"
"\n                       const int        lightCount,"
"\n                       const float      epsilon,"
"\n                       const float      radius,"
"\n                       const int        isShadows,"
"\n                       const int        isReflect,"
"\n                       const int        sizeX,"
"\n                       const int        sizeY )"
"\n     {"
"\n         const int X = get_global_id(0);"
"\n         const int Y = get_global_id(1);"
"\n"
"\n         if( X >= sizeX || Y >= sizeY )"
"\n             return;"
"\n"
"\n         private XRay aRay;"
"\n"
"\n         CreateRay( &aRay,"
"\n                    X,"
"\n                    Y,"
"\n                    sizeX,"
"\n                    sizeY,"
"\n                    origins,"
"\n                    directs );"
"\n"
"\n         float4 boxMin = gNodeMinPoints[0] - (float4)(epsilon, epsilon, epsilon, 0.f);"
"\n         float4 boxMax = gNodeMaxPoints[0] + (float4)(epsilon, epsilon, epsilon, 0.f);"
"\n         float4 color  = (float4)(0.f, 0.f, 0.f, 1.f);"
"\n"
"\n         float timeStart;"
"\n         float timeFinal;"
"\n"
"\n         if( BoxIntersection( &aRay, boxMin, boxMax, &timeStart, &timeFinal ) )"
"\n         {"
"\n             aRay.Origin = fma( aRay.Direct, (float4) (timeStart), aRay.Origin );"
"\n             color = Raytrace( &aRay,"
"\n                               anEnvMap,"
"\n                               gNodeMinPoints,"
"\n                               gNodeMaxPoints,"
"\n                               gNodeDataRecords,"
"\n                               gLightSources,"
"\n                               gMaterials,"
"\n                               gVertices,"
"\n                               gNormals,"
"\n                               gIndices,"
"\n                               lightCount,"
"\n                               epsilon,"
"\n                               radius,"
"\n                               isShadows,"
"\n                               isReflect );"
"\n         }"
"\n         write_imagef( anOutput, (int2)(X, Y), color );"
"\n     }"
        //--------------------------------------------------------------------------
"\n     const sampler_t OutputSampler = CLK_NORMALIZED_COORDS_FALSE | "
"\n                                     CLK_ADDRESS_CLAMP | "
"\n                                     CLK_FILTER_NEAREST;"
"\n     #define DELTA_LUM 0.075f"
"\n     #define AA_MAX 0.559017f"
"\n     #define AA_MIN 0.186339f"
"\n"
        //--------------------------------------------------------------------------
"\n     __kernel void MainSmoothing( __read_only image2d_t  anInput,"
"\n                                  __write_only image2d_t anOutput,"
"\n                                  __read_only  image2d_t anEnvMap,"
"\n                                  __global float4* gNodeMinPoints,"
"\n                                  __global float4* gNodeMaxPoints,"
"\n                                  __global int4*   gNodeDataRecords,"
"\n                                  __global float4* gLightSources,"
"\n                                  __global float4* gMaterials,"
"\n                                  __global float4* gVertices,"
"\n                                  __global float4* gNormals,"
"\n                                  __global int4*   gIndices,"
"\n                                  const float16    origins,"
"\n                                  const float16    directs,"
"\n                                  const int        lightCount,"
"\n                                  const float      epsilon,"
"\n                                  const float      radius,"
"\n                                  const int        isShadows,"
"\n                                  const int        isReflect,"
"\n                                  const int        sizeX,"
"\n                                  const int        sizeY )"
"\n     {"
"\n         const int X = get_global_id (0);"
"\n         const int Y = get_global_id (1);"
"\n"
"\n         if( X >= sizeX || Y >= sizeY )"
"\n             return;"
"\n"
"\n         float4 clr0 = read_imagef( anInput, OutputSampler, (float2)(X + 0, Y + 0) );"
"\n         float4 clr1 = read_imagef( anInput, OutputSampler, (float2)(X + 0, Y - 1) );"
"\n         float4 clr2 = read_imagef( anInput, OutputSampler, (float2)(X + 0, Y + 1) );"
"\n"
"\n         float4 clr3 = read_imagef( anInput, OutputSampler, (float2)(X + 1, Y + 0) );"
"\n         float4 clr4 = read_imagef( anInput, OutputSampler, (float2)(X + 1, Y - 1) );"
"\n         float4 clr5 = read_imagef( anInput, OutputSampler, (float2)(X + 1, Y + 1) );"
"\n"
"\n         float4 clr6 = read_imagef( anInput, OutputSampler, (float2)(X - 1, Y + 0) );"
"\n         float4 clr7 = read_imagef( anInput, OutputSampler, (float2)(X - 1, Y - 1) );"
"\n         float4 clr8 = read_imagef( anInput, OutputSampler, (float2)(X - 1, Y + 1) );"
"\n"
"\n         clr1 = (clr1.w == 1.f) ? -UNIT : clr1;"
"\n         clr2 = (clr2.w == 1.f) ? -UNIT : clr2;"
"\n         clr3 = (clr3.w == 1.f) ? -UNIT : clr3;"
"\n         clr4 = (clr4.w == 1.f) ? -UNIT : clr4;"
"\n         clr5 = (clr5.w == 1.f) ? -UNIT : clr5;"
"\n         clr6 = (clr6.w == 1.f) ? -UNIT : clr6;"
"\n         clr7 = (clr7.w == 1.f) ? -UNIT : clr7;"
"\n         clr8 = (clr8.w == 1.f) ? -UNIT : clr8;"
"\n"
"\n         float aLum = (clr0.w == 1.f) ? -1.f : (0.2126f * clr0.x + 0.7152f * clr0.y + 0.0722f * clr0.z);"
"\n"
"\n         bool render = fabs( 0.2126f * clr1.x + 0.7152f * clr1.y + 0.0722f * clr1.z - aLum ) > DELTA_LUM ||"
"\n                       fabs( 0.2126f * clr2.x + 0.7152f * clr2.y + 0.0722f * clr2.z - aLum ) > DELTA_LUM ||"
"\n                       fabs( 0.2126f * clr3.x + 0.7152f * clr3.y + 0.0722f * clr3.z - aLum ) > DELTA_LUM ||"
"\n                       fabs( 0.2126f * clr4.x + 0.7152f * clr4.y + 0.0722f * clr4.z - aLum ) > DELTA_LUM ||"
"\n                       fabs( 0.2126f * clr5.x + 0.7152f * clr5.y + 0.0722f * clr5.z - aLum ) > DELTA_LUM ||"
"\n                       fabs( 0.2126f * clr6.x + 0.7152f * clr6.y + 0.0722f * clr6.z - aLum ) > DELTA_LUM ||"
"\n                       fabs( 0.2126f * clr7.x + 0.7152f * clr7.y + 0.0722f * clr7.z - aLum ) > DELTA_LUM ||"
"\n                       fabs( 0.2126f * clr8.x + 0.7152f * clr8.y + 0.0722f * clr8.z - aLum ) > DELTA_LUM;"
"\n"
"\n         float4 color = clr0;"
"\n"
"\n         private XRay aRay;"
"\n"
"\n         const float4 boxMin = gNodeMinPoints[0] - (float4)(epsilon, epsilon, epsilon, 0.f);"
"\n         const float4 boxMax = gNodeMaxPoints[0] + (float4)(epsilon, epsilon, epsilon, 0.f);"
"\n"
"\n         if( render )"
"\n         {"
"\n             for( int sample = 0; sample <= 3; ++sample )"
"\n             {"
"\n                 float fX = X, fY = Y;"
"\n"
"\n                 if( sample == 0 )"
"\n                 {"
"\n                     fX -= AA_MIN; fY -= AA_MAX;"
"\n                 }"
"\n                 else if( sample == 1 )"
"\n                 {"
"\n                     fX -= AA_MAX; fY += AA_MIN;"
"\n                 }"
"\n                 else if( sample == 2 )"
"\n                 {"
"\n                     fX += AA_MIN; fY += AA_MAX;"
"\n                 }"
"\n                 else"
"\n                 {"
"\n                     fX += AA_MAX; fY -= AA_MIN;"
"\n                 }"
"\n"
"\n                 CreateRay( &aRay,"
"\n                            fX,"
"\n                            fY,"
"\n                            sizeX,"
"\n                            sizeY,"
"\n                            origins,"
"\n                            directs );"
"\n"
"\n                 float timeStart;"
"\n                 float timeFinal;"
"\n"
"\n                 if( BoxIntersection( &aRay,"
"\n                                      boxMin,"
"\n                                      boxMax,"
"\n                                      &timeStart,"
"\n                                      &timeFinal ) )"
"\n                 {"
"\n                     aRay.Origin = fma( aRay.Direct, (float4)(timeStart), aRay.Origin );"
"\n                     color += Raytrace( &aRay,"
"\n                                        anEnvMap,"
"\n                                        gNodeMinPoints,"
"\n                                        gNodeMaxPoints,"
"\n                                        gNodeDataRecords,"
"\n                                        gLightSources,"
"\n                                        gMaterials,"
"\n                                        gVertices,"
"\n                                        gNormals,"
"\n                                        gIndices,"
"\n                                        lightCount,"
"\n                                        epsilon,"
"\n                                        radius,"
"\n                                        isShadows,"
"\n                                        isReflect );"
"\n                 }"
"\n                 else"
"\n                     color += (float4)( 0.f, 0.f, 0.f, 1.f );"
"\n             }"
"\n             color *= 1.f / 5.f;"
"\n         }"
"\n         write_imagef( anOutput, (int2)(X, Y), color );"
"\n     }"
"\n";
